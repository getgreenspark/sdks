/* tslint:disable */
/* eslint-disable */
/**
 * Reporting
 * Here you can find documentation and examples for Greenspark Reporting API
 *
 * OpenAPI spec version: v1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { InlineResponse200 } from '../models';
import { InlineResponse2001 } from '../models';
import { InlineResponse2002 } from '../models';
import { InlineResponse2003 } from '../models';
import { InlineResponse2004 } from '../models';
import { InlineResponse2005 } from '../models';
import { InlineResponse2006 } from '../models';
import { InlineResponse2007 } from '../models';
import { InlineResponse2008 } from '../models';
import { RawReport } from '../models';
import { RawReportV2 } from '../models';
/**
 * ReportsApi - axios parameter creator
 * @export
 */
export const ReportsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Fetch your impacts page in a raw format.
         * @summary Fetch a Report Page
         * @param {string} reportId The id of a previously generated report.
         * @param {string} cursor The cursor identifies the next page within a report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAReportPage: async (reportId: string, cursor: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportId' is not null or undefined
            if (reportId === null || reportId === undefined) {
                throw new RequiredError('reportId','Required parameter reportId was null or undefined when calling fetchAReportPage.');
            }
            // verify required parameter 'cursor' is not null or undefined
            if (cursor === null || cursor === undefined) {
                throw new RequiredError('cursor','Required parameter cursor was null or undefined when calling fetchAReportPage.');
            }
            const localVarPath = `/v1/reports/{reportId}/{cursor}`
                .replace(`{${"reportId"}}`, encodeURIComponent(String(reportId)))
                .replace(`{${"cursor"}}`, encodeURIComponent(String(cursor)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of average spending on impacts per currency.
         * @summary Fetch Average Spend Per Impact
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchAverageSpendPerImpact: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/average-spend-per-impact`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of spending on impacts of carbon per month.
         * @summary Fetch Carbon By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchCarbonByInterval: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/carbon-by-interval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of spending on impacts on a single type and source.
         * @summary Fetch Impact Amount By Type Per Source Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchImpactAmountByTypePerSourceReport: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/impact-amount-by-type-per-source`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of spending on impacts on a single type and trigger.
         * @summary Fetch Impact Amount By Type Per Trigger Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchImpactAmountByTypePerTriggerReport: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/impact-amount-by-type-per-trigger`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of spending on impacts per month.
         * @summary Fetch Impacts By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchImpactsByInterval: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/impacts-by-interval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of spending on impacts of plastic per month.
         * @summary Fetch Plastic By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchPlasticByInterval: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/plastic-by-interval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch your impacts in a raw format.
         * @summary Fetch Raw Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {string} [impactType] Type can be trees, plastic or carbon. As a result only the impacts containing the provided impact type will be returned. If they contain other impact types as well, those won&#x27;t be filtered out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRawReport: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, impactType?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (impactType !== undefined) {
                localVarQueryParameter['impactType'] = impactType;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch your impacts in a raw format.
         * @summary Fetch Raw Report v2
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {string} [impactType] Type can be trees, plastic or carbon. As a result only the impacts containing the provided impact type will be returned. If they contain other impact types as well, those won&#x27;t be filtered out.
         * @param {string} [cursor] The cursor identifies the next page within a report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchRawReportV2: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, impactType?: string, cursor?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2/reports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (impactType !== undefined) {
                localVarQueryParameter['impactType'] = impactType;
            }

            if (cursor !== undefined) {
                localVarQueryParameter['cursor'] = cursor;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of impacts amount per source.
         * @summary Fetch Total Impact By Sources
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTotalImpactBySources: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/total-impact-by-sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of impacts amount per trigger.
         * @summary Fetch Total Impact By Triggers
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTotalImpactByTriggers: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/total-impact-by-triggers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of spending on impacts on a single type.
         * @summary Fetch Total Impact By Type Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTotalImpactByTypeReport: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/total-impact-by-type`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the total number of impacts.
         * @summary Fetch Total Impacts Count
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTotalImpactsCount: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/total-impacts-count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of total spending on impacts per currency.
         * @summary Fetch Total Spend On Impacts
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTotalSpendOnImpacts: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/total-spend-on-impacts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * Fetch the Array of spending on impacts of trees per month.
         * @summary Fetch Trees By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fetchTreesByInterval: async (sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/reports/trees-by-interval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions :AxiosRequestConfig = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication access-key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
                    ? await configuration.apiKey("x-api-key")
                    : await configuration.apiKey;
                localVarHeaderParameter["x-api-key"] = localVarApiKeyValue;
            }

            if (sourceId !== undefined) {
                localVarQueryParameter['sourceId'] = sourceId;
            }

            if (triggerId !== undefined) {
                localVarQueryParameter['triggerId'] = triggerId;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            const query = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                query.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.params) {
                query.set(key, options.params[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(query)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportsApi - functional programming interface
 * @export
 */
export const ReportsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Fetch your impacts page in a raw format.
         * @summary Fetch a Report Page
         * @param {string} reportId The id of a previously generated report.
         * @param {string} cursor The cursor identifies the next page within a report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAReportPage(reportId: string, cursor: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RawReport>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchAReportPage(reportId, cursor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of average spending on impacts per currency.
         * @summary Fetch Average Spend Per Impact
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAverageSpendPerImpact(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2007>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchAverageSpendPerImpact(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of spending on impacts of carbon per month.
         * @summary Fetch Carbon By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchCarbonByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2003>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchCarbonByInterval(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of spending on impacts on a single type and source.
         * @summary Fetch Impact Amount By Type Per Source Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchImpactAmountByTypePerSourceReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2001>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchImpactAmountByTypePerSourceReport(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of spending on impacts on a single type and trigger.
         * @summary Fetch Impact Amount By Type Per Trigger Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchImpactAmountByTypePerTriggerReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2002>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchImpactAmountByTypePerTriggerReport(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of spending on impacts per month.
         * @summary Fetch Impacts By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchImpactsByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2004>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchImpactsByInterval(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of spending on impacts of plastic per month.
         * @summary Fetch Plastic By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchPlasticByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2003>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchPlasticByInterval(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch your impacts in a raw format.
         * @summary Fetch Raw Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {string} [impactType] Type can be trees, plastic or carbon. As a result only the impacts containing the provided impact type will be returned. If they contain other impact types as well, those won&#x27;t be filtered out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRawReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, impactType?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RawReport>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchRawReport(sourceId, triggerId, startDate, endDate, metadata, impactType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch your impacts in a raw format.
         * @summary Fetch Raw Report v2
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {string} [impactType] Type can be trees, plastic or carbon. As a result only the impacts containing the provided impact type will be returned. If they contain other impact types as well, those won&#x27;t be filtered out.
         * @param {string} [cursor] The cursor identifies the next page within a report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRawReportV2(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, impactType?: string, cursor?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<RawReportV2>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchRawReportV2(sourceId, triggerId, startDate, endDate, metadata, impactType, cursor, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of impacts amount per source.
         * @summary Fetch Total Impact By Sources
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalImpactBySources(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2005>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchTotalImpactBySources(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of impacts amount per trigger.
         * @summary Fetch Total Impact By Triggers
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalImpactByTriggers(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2006>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchTotalImpactByTriggers(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of spending on impacts on a single type.
         * @summary Fetch Total Impact By Type Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalImpactByTypeReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse200>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchTotalImpactByTypeReport(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the total number of impacts.
         * @summary Fetch Total Impacts Count
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalImpactsCount(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2008>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchTotalImpactsCount(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of total spending on impacts per currency.
         * @summary Fetch Total Spend On Impacts
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalSpendOnImpacts(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2007>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchTotalSpendOnImpacts(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * Fetch the Array of spending on impacts of trees per month.
         * @summary Fetch Trees By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTreesByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<InlineResponse2003>>>> {
            const localVarAxiosArgs = await ReportsApiAxiosParamCreator(configuration).fetchTreesByInterval(sourceId, triggerId, startDate, endDate, metadata, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs :AxiosRequestConfig = {...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * ReportsApi - factory interface
 * @export
 */
export const ReportsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * Fetch your impacts page in a raw format.
         * @summary Fetch a Report Page
         * @param {string} reportId The id of a previously generated report.
         * @param {string} cursor The cursor identifies the next page within a report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAReportPage(reportId: string, cursor: string, options?: AxiosRequestConfig): Promise<AxiosResponse<RawReport>> {
            return ReportsApiFp(configuration).fetchAReportPage(reportId, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of average spending on impacts per currency.
         * @summary Fetch Average Spend Per Impact
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchAverageSpendPerImpact(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2007>>> {
            return ReportsApiFp(configuration).fetchAverageSpendPerImpact(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of spending on impacts of carbon per month.
         * @summary Fetch Carbon By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchCarbonByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2003>>> {
            return ReportsApiFp(configuration).fetchCarbonByInterval(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of spending on impacts on a single type and source.
         * @summary Fetch Impact Amount By Type Per Source Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchImpactAmountByTypePerSourceReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2001>>> {
            return ReportsApiFp(configuration).fetchImpactAmountByTypePerSourceReport(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of spending on impacts on a single type and trigger.
         * @summary Fetch Impact Amount By Type Per Trigger Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchImpactAmountByTypePerTriggerReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2002>>> {
            return ReportsApiFp(configuration).fetchImpactAmountByTypePerTriggerReport(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of spending on impacts per month.
         * @summary Fetch Impacts By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchImpactsByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2004>>> {
            return ReportsApiFp(configuration).fetchImpactsByInterval(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of spending on impacts of plastic per month.
         * @summary Fetch Plastic By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchPlasticByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2003>>> {
            return ReportsApiFp(configuration).fetchPlasticByInterval(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch your impacts in a raw format.
         * @summary Fetch Raw Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {string} [impactType] Type can be trees, plastic or carbon. As a result only the impacts containing the provided impact type will be returned. If they contain other impact types as well, those won&#x27;t be filtered out.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRawReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, impactType?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<RawReport>> {
            return ReportsApiFp(configuration).fetchRawReport(sourceId, triggerId, startDate, endDate, metadata, impactType, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch your impacts in a raw format.
         * @summary Fetch Raw Report v2
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {string} [impactType] Type can be trees, plastic or carbon. As a result only the impacts containing the provided impact type will be returned. If they contain other impact types as well, those won&#x27;t be filtered out.
         * @param {string} [cursor] The cursor identifies the next page within a report.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchRawReportV2(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, impactType?: string, cursor?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<RawReportV2>> {
            return ReportsApiFp(configuration).fetchRawReportV2(sourceId, triggerId, startDate, endDate, metadata, impactType, cursor, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of impacts amount per source.
         * @summary Fetch Total Impact By Sources
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalImpactBySources(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2005>>> {
            return ReportsApiFp(configuration).fetchTotalImpactBySources(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of impacts amount per trigger.
         * @summary Fetch Total Impact By Triggers
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalImpactByTriggers(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2006>>> {
            return ReportsApiFp(configuration).fetchTotalImpactByTriggers(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of spending on impacts on a single type.
         * @summary Fetch Total Impact By Type Report
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalImpactByTypeReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse200>>> {
            return ReportsApiFp(configuration).fetchTotalImpactByTypeReport(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the total number of impacts.
         * @summary Fetch Total Impacts Count
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalImpactsCount(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<InlineResponse2008>> {
            return ReportsApiFp(configuration).fetchTotalImpactsCount(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of total spending on impacts per currency.
         * @summary Fetch Total Spend On Impacts
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTotalSpendOnImpacts(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2007>>> {
            return ReportsApiFp(configuration).fetchTotalSpendOnImpacts(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
        /**
         * Fetch the Array of spending on impacts of trees per month.
         * @summary Fetch Trees By Interval
         * @param {string} [sourceId] The id of the source associated with the impact.
         * @param {string} [triggerId] The id of the trigger associated with the impact.
         * @param {string} [startDate] The beginning of the date filter interval.
         * @param {string} [endDate] The end of the date filter interval.
         * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fetchTreesByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig): Promise<AxiosResponse<Array<InlineResponse2003>>> {
            return ReportsApiFp(configuration).fetchTreesByInterval(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ReportsApi - object-oriented interface
 * @export
 * @class ReportsApi
 * @extends {BaseAPI}
 */
export class ReportsApi extends BaseAPI {
    /**
     * Fetch your impacts page in a raw format.
     * @summary Fetch a Report Page
     * @param {string} reportId The id of a previously generated report.
     * @param {string} cursor The cursor identifies the next page within a report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchAReportPage(reportId: string, cursor: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<RawReport>> {
        return ReportsApiFp(this.configuration).fetchAReportPage(reportId, cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of average spending on impacts per currency.
     * @summary Fetch Average Spend Per Impact
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchAverageSpendPerImpact(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2007>>> {
        return ReportsApiFp(this.configuration).fetchAverageSpendPerImpact(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of spending on impacts of carbon per month.
     * @summary Fetch Carbon By Interval
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchCarbonByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2003>>> {
        return ReportsApiFp(this.configuration).fetchCarbonByInterval(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of spending on impacts on a single type and source.
     * @summary Fetch Impact Amount By Type Per Source Report
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchImpactAmountByTypePerSourceReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2001>>> {
        return ReportsApiFp(this.configuration).fetchImpactAmountByTypePerSourceReport(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of spending on impacts on a single type and trigger.
     * @summary Fetch Impact Amount By Type Per Trigger Report
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchImpactAmountByTypePerTriggerReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2002>>> {
        return ReportsApiFp(this.configuration).fetchImpactAmountByTypePerTriggerReport(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of spending on impacts per month.
     * @summary Fetch Impacts By Interval
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchImpactsByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2004>>> {
        return ReportsApiFp(this.configuration).fetchImpactsByInterval(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of spending on impacts of plastic per month.
     * @summary Fetch Plastic By Interval
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchPlasticByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2003>>> {
        return ReportsApiFp(this.configuration).fetchPlasticByInterval(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch your impacts in a raw format.
     * @summary Fetch Raw Report
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {string} [impactType] Type can be trees, plastic or carbon. As a result only the impacts containing the provided impact type will be returned. If they contain other impact types as well, those won&#x27;t be filtered out.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchRawReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, impactType?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<RawReport>> {
        return ReportsApiFp(this.configuration).fetchRawReport(sourceId, triggerId, startDate, endDate, metadata, impactType, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch your impacts in a raw format.
     * @summary Fetch Raw Report v2
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {string} [impactType] Type can be trees, plastic or carbon. As a result only the impacts containing the provided impact type will be returned. If they contain other impact types as well, those won&#x27;t be filtered out.
     * @param {string} [cursor] The cursor identifies the next page within a report.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchRawReportV2(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, impactType?: string, cursor?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<RawReportV2>> {
        return ReportsApiFp(this.configuration).fetchRawReportV2(sourceId, triggerId, startDate, endDate, metadata, impactType, cursor, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of impacts amount per source.
     * @summary Fetch Total Impact By Sources
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchTotalImpactBySources(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2005>>> {
        return ReportsApiFp(this.configuration).fetchTotalImpactBySources(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of impacts amount per trigger.
     * @summary Fetch Total Impact By Triggers
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchTotalImpactByTriggers(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2006>>> {
        return ReportsApiFp(this.configuration).fetchTotalImpactByTriggers(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of spending on impacts on a single type.
     * @summary Fetch Total Impact By Type Report
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchTotalImpactByTypeReport(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse200>>> {
        return ReportsApiFp(this.configuration).fetchTotalImpactByTypeReport(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the total number of impacts.
     * @summary Fetch Total Impacts Count
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchTotalImpactsCount(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<InlineResponse2008>> {
        return ReportsApiFp(this.configuration).fetchTotalImpactsCount(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of total spending on impacts per currency.
     * @summary Fetch Total Spend On Impacts
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchTotalSpendOnImpacts(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2007>>> {
        return ReportsApiFp(this.configuration).fetchTotalSpendOnImpacts(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Fetch the Array of spending on impacts of trees per month.
     * @summary Fetch Trees By Interval
     * @param {string} [sourceId] The id of the source associated with the impact.
     * @param {string} [triggerId] The id of the trigger associated with the impact.
     * @param {string} [startDate] The beginning of the date filter interval.
     * @param {string} [endDate] The end of the date filter interval.
     * @param {string} [metadata] You can filter the data by the provided key-value pairs as Metadata.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportsApi
     */
    public async fetchTreesByInterval(sourceId?: string, triggerId?: string, startDate?: string, endDate?: string, metadata?: string, options?: AxiosRequestConfig) : Promise<AxiosResponse<Array<InlineResponse2003>>> {
        return ReportsApiFp(this.configuration).fetchTreesByInterval(sourceId, triggerId, startDate, endDate, metadata, options).then((request) => request(this.axios, this.basePath));
    }
}
